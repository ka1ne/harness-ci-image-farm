template:
  name: Harness ECR Image Ingestion with Scanning
  identifier: harness_ecr_image_ingestion
  versionLabel: "1.0.0"
  type: Pipeline
  projectIdentifier: ${PROJECT_ID}
  orgIdentifier: ${ORG_ID}
  tags:
    role: harness-image-ingestion
    source: ecr
    scope: template
  spec:
    variables:
      - name: source_registry
        description: "ECR Public Registry source (e.g. public.ecr.aws/harness)"
        type: String
        value: <+input>.default("public.ecr.aws/harness")
      - name: target_registry
        description: "Target container registry to store images"
        type: String
        value: <+input>
      - name: registry_connector_source
        description: "Connector ID for source registry authentication (if needed)"
        type: String
        value: <+input>
      - name: registry_connector_target
        description: "Connector ID for target registry"
        type: String
        value: <+input>
      - name: scan_images
        description: "Whether to scan images for vulnerabilities"
        type: String
        value: <+input>.allowedValues(true,false).default("true")
      - name: fail_on_severity
        description: "Severity level to fail the build"
        type: String
        value: <+input>.allowedValues(CRITICAL,HIGH,MEDIUM,LOW,UNKNOWN).default("CRITICAL")
      - name: filter_prefix
        description: "Filter images by name prefix (e.g., ci-)"
        type: String
        value: <+input>.default("")
      - name: harness_only
        description: "Only process Harness official images"
        type: String
        value: <+input>.allowedValues(true,false).default("true")
      - name: max_concurrency
        description: "Maximum number of concurrent operations"
        type: Number
        value: <+input>.default(5)
    
    stages:
      - stage:
          name: Discover New Images
          identifier: discover_new_images
          description: Query the ECR Public Registry API for available images
          type: Custom
          spec:
            execution:
              steps:
                - step:
                    type: ShellScript
                    name: Query ECR Public Registry
                    identifier: query_ecr_public_registry
                    spec:
                      shell: Bash
                      source:
                        type: Inline
                        spec:
                          script: |
                            #!/bin/bash
                            set -e
                            
                            # Install AWS CLI if not available
                            if ! command -v aws &> /dev/null; then
                                echo "Installing AWS CLI..."
                                curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                                unzip -q awscliv2.zip
                                ./aws/install
                                rm -rf aws awscliv2.zip
                            fi
                            
                            # Set variables from pipeline
                            SOURCE_REGISTRY="<+pipeline.variables.source_registry>"
                            FILTER_PREFIX="<+pipeline.variables.filter_prefix>"
                            HARNESS_ONLY="<+pipeline.variables.harness_only>"
                            
                            # Query ECR public registry
                            echo "Querying ECR Public Registry: $SOURCE_REGISTRY"
                            
                            # Parse registry into components
                            REGISTRY_HOST=$(echo $SOURCE_REGISTRY | cut -d'/' -f1)
                            REGISTRY_NAMESPACE=$(echo $SOURCE_REGISTRY | cut -d'/' -f2)
                            
                            # Query registry for repositories
                            if [[ $HARNESS_ONLY == "true" ]]; then
                              echo "Filtering for official Harness images only"
                              REPOS=$(aws ecr-public describe-repositories --region us-east-1 --registry-id $REGISTRY_NAMESPACE --query "repositories[?repositoryName.contains(@,'harness') || repositoryName.contains(@,'drone')].repositoryName" --output json)
                            else
                              echo "Getting all repositories"
                              REPOS=$(aws ecr-public describe-repositories --region us-east-1 --registry-id $REGISTRY_NAMESPACE --query "repositories[*].repositoryName" --output json)
                            fi
                            
                            # Apply prefix filter if specified
                            if [[ ! -z "$FILTER_PREFIX" ]]; then
                              echo "Applying filter prefix: $FILTER_PREFIX"
                              REPOS=$(echo $REPOS | jq -c "[.[] | select(startswith(\"$FILTER_PREFIX\"))]")
                            fi
                            
                            # Get latest tag for each repository
                            IMAGES=""
                            for REPO in $(echo $REPOS | jq -r '.[]'); do
                              echo "Getting tags for $REPO..."
                              
                              # Get image tags
                              TAGS=$(aws ecr-public describe-image-tags --region us-east-1 --repository-name $REPO --registry-id $REGISTRY_NAMESPACE --query "imageTagDetails[*].imageTag" --output json)
                              
                              # Get latest tag (sorted semantically if possible)
                              LATEST_TAG=$(echo $TAGS | jq -r 'sort_by(split(".") | map(if test("^[0-9]+$") then tonumber else . end)) | last')
                              
                              if [[ $LATEST_TAG != "null" ]]; then
                                if [[ ! -z "$IMAGES" ]]; then
                                  IMAGES="$IMAGES,$REPO=$REPO:$LATEST_TAG"
                                else
                                  IMAGES="$REPO=$REPO:$LATEST_TAG"
                                fi
                                echo "Added $REPO:$LATEST_TAG to process queue"
                              fi
                            done
                            
                            echo "Total images to process: $(echo $IMAGES | tr ',' '\n' | wc -l)"
                            harness_io out images="$IMAGES"
                      environmentVariables: []
                    timeout: 15m
      
      - stage:
          name: Process Images
          identifier: process_images
          description: Pull, scan, and push each discovered image
          type: Custom
          strategy:
            repeat:
              items: <+pipeline.stages.discover_new_images.spec.execution.steps.query_ecr_public_registry.output.outputVariables.images.split(",")>
              maxConcurrency: <+pipeline.variables.max_concurrency>
          spec:
            execution:
              steps:
                - step:
                    type: ShellScript
                    name: Check If Image Already Exists
                    identifier: check_image_exists
                    spec:
                      shell: Bash
                      source:
                        type: Inline
                        spec:
                          script: |
                            #!/bin/bash
                            set -e
                            
                            # Parse image info
                            REPO_NAME="<+repeat.item.split('=')[0]>"
                            IMAGE_FULL="<+repeat.item.split('=')[1]>"
                            IMAGE_NAME=$(echo $IMAGE_FULL | cut -d':' -f1)
                            IMAGE_TAG=$(echo $IMAGE_FULL | cut -d':' -f2)
                            TARGET_REGISTRY="<+pipeline.variables.target_registry>"
                            
                            echo "Checking if image $TARGET_REGISTRY/$IMAGE_NAME:$IMAGE_TAG already exists..."
                            
                            # Setup the skopeo command for registry interaction
                            if command -v skopeo &> /dev/null; then
                              if skopeo inspect "docker://$TARGET_REGISTRY/$IMAGE_NAME:$IMAGE_TAG" &>/dev/null; then
                                echo "Image $TARGET_REGISTRY/$IMAGE_NAME:$IMAGE_TAG already exists in registry"
                                harness_io out image_exists="true"
                                harness_io out repo_name="$REPO_NAME"
                                harness_io out image_name="$IMAGE_NAME"
                                harness_io out image_tag="$IMAGE_TAG"
                                harness_io out image_full="$IMAGE_FULL"
                              else
                                echo "Image does not exist, will process"
                                harness_io out image_exists="false"
                                harness_io out repo_name="$REPO_NAME"
                                harness_io out image_name="$IMAGE_NAME"
                                harness_io out image_tag="$IMAGE_TAG"
                                harness_io out image_full="$IMAGE_FULL"
                              fi
                            else
                              # Alternative approach using docker
                              if docker pull "$TARGET_REGISTRY/$IMAGE_NAME:$IMAGE_TAG" &>/dev/null; then
                                echo "Image $TARGET_REGISTRY/$IMAGE_NAME:$IMAGE_TAG already exists in registry"
                                harness_io out image_exists="true"
                                harness_io out repo_name="$REPO_NAME"
                                harness_io out image_name="$IMAGE_NAME"
                                harness_io out image_tag="$IMAGE_TAG"
                                harness_io out image_full="$IMAGE_FULL"
                              else
                                echo "Image does not exist, will process"
                                harness_io out image_exists="false"
                                harness_io out repo_name="$REPO_NAME"
                                harness_io out image_name="$IMAGE_NAME"
                                harness_io out image_tag="$IMAGE_TAG"
                                harness_io out image_full="$IMAGE_FULL"
                              fi
                            fi
                      environmentVariables: []
                    timeout: 5m
                
                - step:
                    type: ShellScript
                    name: Pull Source Image
                    identifier: pull_source_image
                    spec:
                      shell: Bash
                      source:
                        type: Inline
                        spec:
                          script: |
                            #!/bin/bash
                            set -e
                            
                            SOURCE_REGISTRY="<+pipeline.variables.source_registry>"
                            IMAGE_NAME="<+execution.steps.check_image_exists.output.outputVariables.image_name>"
                            IMAGE_TAG="<+execution.steps.check_image_exists.output.outputVariables.image_tag>"
                            
                            echo "Pulling image $SOURCE_REGISTRY/$IMAGE_NAME:$IMAGE_TAG"
                            docker pull "$SOURCE_REGISTRY/$IMAGE_NAME:$IMAGE_TAG"
                            
                            echo "Image pulled successfully"
                      environmentVariables: []
                    timeout: 10m
                    when:
                      stageStatus: Success
                      condition: <+execution.steps.check_image_exists.output.outputVariables.image_exists> == "false"
                
                - step:
                    type: ShellScript
                    name: Scan Image for Vulnerabilities
                    identifier: scan_image
                    spec:
                      shell: Bash
                      source:
                        type: Inline
                        spec:
                          script: |
                            #!/bin/bash
                            set -e
                            
                            SOURCE_REGISTRY="<+pipeline.variables.source_registry>"
                            IMAGE_NAME="<+execution.steps.check_image_exists.output.outputVariables.image_name>"
                            IMAGE_TAG="<+execution.steps.check_image_exists.output.outputVariables.image_tag>"
                            FAIL_ON_SEVERITY="<+pipeline.variables.fail_on_severity>"
                            
                            # Install Trivy if not available
                            if ! command -v trivy &> /dev/null; then
                              echo "Installing Trivy vulnerability scanner..."
                              curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin v0.38.0
                            fi
                            
                            # Scan the image
                            echo "Scanning image $SOURCE_REGISTRY/$IMAGE_NAME:$IMAGE_TAG for vulnerabilities..."
                            SEVERITY_ARGS=""
                            case "$FAIL_ON_SEVERITY" in
                              "CRITICAL")
                                SEVERITY_ARGS="CRITICAL"
                                ;;
                              "HIGH")
                                SEVERITY_ARGS="CRITICAL,HIGH"
                                ;;
                              "MEDIUM")
                                SEVERITY_ARGS="CRITICAL,HIGH,MEDIUM"
                                ;;
                              "LOW")
                                SEVERITY_ARGS="CRITICAL,HIGH,MEDIUM,LOW"
                                ;;
                              "UNKNOWN")
                                SEVERITY_ARGS="CRITICAL,HIGH,MEDIUM,LOW,UNKNOWN"
                                ;;
                            esac
                            
                            # Create results directory
                            mkdir -p scan-results
                            
                            # Run scan
                            set +e
                            trivy image --no-progress --severity $SEVERITY_ARGS --format json -o scan-results/results.json "$SOURCE_REGISTRY/$IMAGE_NAME:$IMAGE_TAG"
                            SCAN_EXIT_CODE=$?
                            set -e
                            
                            # Process scan results
                            if [ $SCAN_EXIT_CODE -ne 0 ]; then
                              echo "⚠️ Vulnerabilities found at severity level $FAIL_ON_SEVERITY or higher"
                              VULN_COUNT=$(cat scan-results/results.json | jq '.Results | map(.Vulnerabilities // []) | flatten | length')
                              echo "Found $VULN_COUNT vulnerabilities"
                              
                              # Generate a summary report
                              echo "## Vulnerability Summary" > scan-results/summary.md
                              echo "Image: $SOURCE_REGISTRY/$IMAGE_NAME:$IMAGE_TAG" >> scan-results/summary.md
                              echo "Total vulnerabilities: $VULN_COUNT" >> scan-results/summary.md
                              echo "" >> scan-results/summary.md
                              
                              # Add counts by severity
                              echo "### Counts by Severity" >> scan-results/summary.md
                              cat scan-results/results.json | jq -r '.Results | map(.Vulnerabilities // []) | flatten | group_by(.Severity) | map({severity: .[0].Severity, count: length}) | .[] | "- \(.severity): \(.count)"' >> scan-results/summary.md
                              echo "" >> scan-results/summary.md
                              
                              # List critical vulnerabilities
                              echo "### Critical Vulnerabilities" >> scan-results/summary.md
                              cat scan-results/results.json | jq -r '.Results | map(.Vulnerabilities // []) | flatten | select(.Severity == "CRITICAL") | "- \(.VulnerabilityID): \(.Title)"' >> scan-results/summary.md
                              
                              # Based on scanning policy, decide whether to fail or not
                              if [[ "<+pipeline.variables.scan_images>" == "true" ]]; then
                                echo "❌ Failing build due to security policy"
                                exit 1
                              else
                                echo "⚠️ Continuing despite vulnerabilities (scan_images is false)"
                              fi
                            else
                              echo "✅ No vulnerabilities found at severity level $FAIL_ON_SEVERITY or higher"
                            fi
                      environmentVariables: []
                    timeout: 15m
                    when:
                      stageStatus: Success
                      condition: <+execution.steps.check_image_exists.output.outputVariables.image_exists> == "false" && <+pipeline.variables.scan_images> == "true"
                
                - step:
                    type: ShellScript
                    name: Tag and Push Image
                    identifier: tag_and_push_image
                    spec:
                      shell: Bash
                      source:
                        type: Inline
                        spec:
                          script: |
                            #!/bin/bash
                            set -e
                            
                            SOURCE_REGISTRY="<+pipeline.variables.source_registry>"
                            TARGET_REGISTRY="<+pipeline.variables.target_registry>"
                            IMAGE_NAME="<+execution.steps.check_image_exists.output.outputVariables.image_name>"
                            IMAGE_TAG="<+execution.steps.check_image_exists.output.outputVariables.image_tag>"
                            
                            # Tag and push the image
                            echo "Tagging image $SOURCE_REGISTRY/$IMAGE_NAME:$IMAGE_TAG as $TARGET_REGISTRY/$IMAGE_NAME:$IMAGE_TAG"
                            docker tag "$SOURCE_REGISTRY/$IMAGE_NAME:$IMAGE_TAG" "$TARGET_REGISTRY/$IMAGE_NAME:$IMAGE_TAG"
                            
                            echo "Pushing image to $TARGET_REGISTRY/$IMAGE_NAME:$IMAGE_TAG"
                            docker push "$TARGET_REGISTRY/$IMAGE_NAME:$IMAGE_TAG"
                            
                            echo "Image pushed successfully"
                      environmentVariables: []
                    timeout: 10m
                    when:
                      stageStatus: Success
                      condition: <+execution.steps.check_image_exists.output.outputVariables.image_exists> == "false"
                
                - step:
                    type: ShellScript
                    name: Verify Pushed Image
                    identifier: verify_pushed_image
                    spec:
                      shell: Bash
                      source:
                        type: Inline
                        spec:
                          script: |
                            #!/bin/bash
                            set -e
                            
                            TARGET_REGISTRY="<+pipeline.variables.target_registry>"
                            IMAGE_NAME="<+execution.steps.check_image_exists.output.outputVariables.image_name>"
                            IMAGE_TAG="<+execution.steps.check_image_exists.output.outputVariables.image_tag>"
                            
                            echo "Verifying image $TARGET_REGISTRY/$IMAGE_NAME:$IMAGE_TAG"
                            
                            # Clear local image first to ensure we're pulling from registry
                            docker rmi "$TARGET_REGISTRY/$IMAGE_NAME:$IMAGE_TAG" || true
                            
                            # Try to pull the image to verify it exists
                            if docker pull "$TARGET_REGISTRY/$IMAGE_NAME:$IMAGE_TAG" &>/dev/null; then
                              echo "✅ Image $TARGET_REGISTRY/$IMAGE_NAME:$IMAGE_TAG verified in registry"
                            else
                              echo "❌ Failed to verify image $TARGET_REGISTRY/$IMAGE_NAME:$IMAGE_TAG in registry"
                              exit 1
                            fi
                      environmentVariables: []
                    timeout: 5m
                    when:
                      stageStatus: Success
                      condition: <+execution.steps.check_image_exists.output.outputVariables.image_exists> == "false"
      
      - stage:
          name: Generate Report
          identifier: generate_report
          description: Generate a summary report of processed images
          type: Custom
          spec:
            execution:
              steps:
                - step:
                    type: ShellScript
                    name: Summarize Image Processing
                    identifier: summarize_image_processing
                    spec:
                      shell: Bash
                      source:
                        type: Inline
                        spec:
                          script: |
                            #!/bin/bash
                            set -e
                            
                            SOURCE_REGISTRY="<+pipeline.variables.source_registry>"
                            TARGET_REGISTRY="<+pipeline.variables.target_registry>"
                            IMAGES="<+pipeline.stages.discover_new_images.spec.execution.steps.query_ecr_public_registry.output.outputVariables.images>"
                            
                            # Calculate stats
                            TOTAL_IMAGES=$(echo "$IMAGES" | tr ',' '\n' | wc -l)
                            
                            echo "========================================"
                            echo "   ECR Image Ingestion Summary Report"
                            echo "========================================"
                            echo ""
                            echo "Source Registry: $SOURCE_REGISTRY"
                            echo "Target Registry: $TARGET_REGISTRY"
                            echo "Total Images Processed: $TOTAL_IMAGES"
                            echo ""
                            echo "Images:"
                            for IMG in $(echo "$IMAGES" | tr ',' '\n'); do
                              REPO=$(echo $IMG | cut -d'=' -f1)
                              IMAGE=$(echo $IMG | cut -d'=' -f2)
                              echo "- $IMAGE → $TARGET_REGISTRY/$(echo $IMAGE | cut -d':' -f1):$(echo $IMAGE | cut -d':' -f2)"
                            done
                            
                            echo ""
                            echo "Process completed successfully!"
                      environmentVariables: []
                    timeout: 5m
      
      - stage:
          name: Configure Harness Platform (Optional)
          identifier: configure_harness_platform
          description: Updates the Harness Platform to use the newly pushed images as the default versions
          type: Custom
          when:
            pipelineStatus: Success
            condition: <+pipeline.variables.harness_only> == "true"
          spec:
            execution:
              steps:
                - step:
                    type: ShellScript
                    name: Update Harness Platform Configuration
                    identifier: update_harness_platform_configuration
                    spec:
                      shell: Bash
                      source:
                        type: Inline
                        spec:
                          script: |
                            #!/bin/bash
                            set -e
                            
                            echo "This step would update the Harness platform configuration to use the ingested images."
                            echo "For implementation, you'd need to integrate with the Harness API to update the CI execution configuration."
                            echo "See the 'Update Harness CI Image Configuration' stage in the harness-image-factory-complete.yaml for reference."
                      environmentVariables: []
                    timeout: 5m
  
    timeout: 120m 